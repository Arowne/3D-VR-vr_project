<!DOCTYPE html>
<html lang="en">

<head>
	<title>three.js vr - ball shooter</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
	<link type="text/css" rel="stylesheet" href="main.css">
	<!-- WebXR Device API (For Chrome M76+), expires 12/04/2019 -->
	<meta http-equiv="origin-trial"
		content="Aq9LklhCLNUveuCr7QTpGpqwCPG817cYHdVyQuJPOZYk47iRB390lUKa5edVmgS1pZSl8HPspElEC/91Fz55dwIAAABTeyJvcmlnaW4iOiJodHRwczovL3RocmVlanMub3JnOjQ0MyIsImZlYXR1cmUiOiJXZWJYUkRldmljZU03NiIsImV4cGlyeSI6MTU3NTQxNzU5OX0=">
</head>

<body>

	<div id="info">
		<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> vr - ball shooter
	</div>

	<script src="js/vr/HelioWebXRPolyfill.js"></script>

	<script type="module">
		import * as THREE from '../build/three.module.js';
		import { BoxLineGeometry } from './jsm/geometries/BoxLineGeometry.js';
		import { VRButton } from './jsm/webxr/VRButton.js';
		var camera, scene, renderer, circle;
		var controller1, controller2;
		var room;
		var count = 0;
		var radius = 0.005;
		var normal = new THREE.Vector3();
		var relativeVelocity = new THREE.Vector3();
		var clock = new THREE.Clock();
		init();
		animate();
		function init() {
			scene = new THREE.Scene();
			scene.background = new THREE.Color(0x505050);
			camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
			camera.position.set(0, 1.6, 3);
			room = new THREE.LineSegments(
				new BoxLineGeometry(50, 50, 50, 100, 100, 100),
				new THREE.LineBasicMaterial({ color: 0x808080 })
			);
			room.geometry.translate(0, 3, 0);
			scene.add(room);

			//Create light
			var light = new THREE.HemisphereLight(0xffffff, 0x444444);
			light.position.set(1, 1, 1);
			scene.add(light);

			// Create target
			var geometry = new THREE.CircleGeometry(0.5, 32);
			var material = new THREE.MeshBasicMaterial({ color: 0xffff00 });
			circle = new THREE.Mesh(geometry, material);
			circle.position.x = 0.5 * 4 - 2;
			circle.position.y = 0.5 * 4;
			circle.position.z = -2;
			scene.add(circle);

			// Create ball
			var geometry = new THREE.IcosahedronBufferGeometry(radius, 2);
			var object = new THREE.Mesh(geometry, new THREE.MeshLambertMaterial({ color: 0xffffff }));
			object.position.x = 0.5 * 4 - 2;
			object.position.y = 0.5 * 4;
			object.position.z = 0.5 * 4 - 2;
			object.userData.velocity = new THREE.Vector3();
			object.userData.velocity.x = 0.5 * 0.01 - 0.005;
			object.userData.velocity.y = 0.5 * 0.01 - 0.005;
			object.userData.velocity.z = 0.5 * 0.01 - 0.005;
			room.add(object);

			//
			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.vr.enabled = true;
			document.body.appendChild(renderer.domElement);
			//
			document.body.appendChild(VRButton.createButton(renderer));
			// controllers
			function onSelectStart() {
				this.userData.isSelecting = true;
			}
			function onSelectEnd() {
				this.userData.isSelecting = false;
			}

			controller1 = renderer.vr.getController(0);
			controller1.addEventListener('selectstart', onSelectStart);
			controller1.addEventListener('selectend', onSelectEnd);

			controller2 = renderer.vr.getController(1);
			controller2.addEventListener('selectstart', onSelectStart);
			controller2.addEventListener('selectend', onSelectEnd);
			scene.add(controller2);

			// Add line guide
			var geometry = new THREE.BufferGeometry();
			geometry.setAttribute('position', new THREE.Float32BufferAttribute([0, 0, 0, 0, 0, - 1], 3));
			geometry.setAttribute('color', new THREE.Float32BufferAttribute([0.5, 0.5, 0.5, 0, 0, 0], 3));
			var material = new THREE.LineBasicMaterial({ vertexColors: true, blending: THREE.AdditiveBlending });
			controller1.add(new THREE.Line(geometry, material));
			controller2.add(new THREE.Line(geometry, material));

			//
			window.addEventListener('resize', onWindowResize, false);
		}

		function createTarget(scene) {

		}

		function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize(window.innerWidth, window.innerHeight);
		}

		function handleController(controller) {
			if (controller.userData.isSelecting) {
				var object = room.children[0];
				object.position.copy(controller.position);
				object.position.y += 1
				object.userData.velocity.x = (0.5 - 0.5) * 3;
				object.userData.velocity.y = (0.5 - 0.5) * 3;
				object.userData.velocity.z = (0.5 - 9);
				object.userData.velocity.applyQuaternion(controller.quaternion);
			}
		}
		//
		function animate() {
			renderer.setAnimationLoop(render);
		}
		function render() {
			handleController(controller1);
			handleController(controller2);
			//
			var delta = clock.getDelta() * 5; // slow down simulation
			var range = 3 - radius;
			var object = room.children[0];
			object.position.x += object.userData.velocity.x * delta;
			object.position.y += object.userData.velocity.y * delta;
			object.position.z += object.userData.velocity.z * delta;

			// Wall collision
			if (object.position.x < - range || object.position.x > range) {
				object.position.x = THREE.Math.clamp(object.position.x, - range, range);
				object.userData.velocity.x = - object.userData.velocity.x;
			}
			if (object.position.y < radius || object.position.y > 6) {
				object.position.y = Math.max(object.position.y, radius);
				object.userData.velocity.x *= 0.98;
				object.userData.velocity.y = - object.userData.velocity.y * 0.8;
				object.userData.velocity.z *= 0.98;
			}
			if (object.position.z < - range || object.position.z > range) {
				object.position.z = THREE.Math.clamp(object.position.z, - range, range);
				object.userData.velocity.z = - object.userData.velocity.z;
			}

			object.userData.velocity.y -= 9.8 * delta;
			renderer.render(scene, camera);
		}
	</script>
</body>

</html>